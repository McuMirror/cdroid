#ifndef __MENU_BUILDER_H__
#define __MENU_BUILDER_H__
#include <view/menu.h>
namespace cdroid{
class MenuItemImpl;
class MenuPresenter;
class SubMenuBuilder;
class MenuBuilder:public Menu {
private:
    static constexpr const char* PRESENTER_KEY = "android:menu:presenters";
    static constexpr const char* ACTION_VIEW_STATES_KEY = "android:menu:actionviewstates";
    static constexpr const char* EXPANDED_ACTION_VIEW_ID = "android:menu:expandedactionview";
#if 0
    static int[]  sCategoryToOrder = new int[] {
        1, /* No category */
        4, /* CONTAINER */
        5, /* SYSTEM */
        3, /* SECONDARY */
        2, /* ALTERNATIVE */
        0, /* SELECTED_ALTERNATIVE */
    };
#endif
    friend MenuItemImpl;
    friend SubMenuBuilder;
public:
    struct Callback {
        std::function<bool(MenuBuilder&,MenuItem&)> onMenuItemSelected;
        std::function<void(MenuBuilder&)> onMenuModeChange;
    };

    typedef std::function<bool(MenuItemImpl&)>ItemInvoker;
private:
    Context* mContext;

    /**
     * Whether the shortcuts should be qwerty-accessible. Use isQwertyMode()
     * instead of accessing this directly.
     */
    bool mQwertyMode;

    /**
     * Whether the shortcuts should be visible on menus. Use isShortcutsVisible()
     * instead of accessing this directly.
     */
    bool mShortcutsVisible;

    /**
     * Callback that will receive the various menu-related events generated by
     * this class. Use getCallback to get a reference to the callback.
     */
    Callback mCallback;

    /** Contains all of the items for this menu */
    std::vector<MenuItemImpl*> mItems;

    /** Contains only the items that are currently visible.  This will be created/refreshed from
     * {@link #getVisibleItems()} */
    std::vector<MenuItemImpl*> mVisibleItems;

    /**
     * Contains only the items that should appear in the Action Bar, if present.
     */
    std::vector<MenuItemImpl*> mActionItems;
    /**
     * Contains items that should NOT appear in the Action Bar, if present.
     */
    std::vector<MenuItemImpl*> mNonActionItems;

    /**
     * Default value for how added items should show in the action list.
     */
    int mDefaultShowAsAction = MenuItem::SHOW_AS_ACTION_NEVER;

    /**
     * Current use case is Context Menus: As Views populate the context menu, each one has
     * extra information that should be passed along.  This is the current menu info that
     * should be set on all items added to this menu.
     */
    ContextMenuInfo* mCurrentMenuInfo;

    SparseArray<Parcelable> mFrozenViewStates;

    bool mIsVisibleItemsStale;
    bool mIsActionItemsStale;
    bool mPreventDispatchingItemsChanged = false;
    bool mItemsChangedWhileDispatchPrevented = false;
    bool mOptionalIconsVisible = false;
    bool mIsClosing = false;
    bool mGroupDividerEnabled = false;

    std::vector<MenuItemImpl*> mTempShortcutItemList;

    std::vector<MenuPresenter*> mPresenters;
    MenuItemImpl* mExpandedItem;
private:
    void dispatchPresenterUpdate(bool cleared);
    bool dispatchSubMenuSelected(SubMenuBuilder& subMenu,MenuPresenter& preferredPresenter);
    void dispatchSaveInstanceState(Bundle outState);
    void dispatchRestoreInstanceState(Bundle state);
    /**
     * Adds an item to the menu.  The other add methods funnel to this.
     */
    MenuItem* addInternal(int group, int id, int categoryOrder, const std::string& title);

    // Layoutlib overrides this method to return its custom implementation of MenuItemImpl
    MenuItemImpl* createNewMenuItem(int group, int id, int categoryOrder, int ordering,
            const std::string&title, int defaultShowAsAction);
    void removeItemAtInt(int index, bool updateChildrenOnMenuViews);
    static int getOrdering(int categoryOrder);
    void setShortcutsVisibleInner(bool shortcutsVisible);
    static int findInsertIndex(const std::vector<MenuItemImpl*>& items, int ordering);
    void setHeaderInternal(int titleRes, const std::string& title,int iconRes, Drawable* icon,View view);

protected:
    /** Header title for menu types that have a header (context and submenus) */
    std::string mHeaderTitle;
    /** Header icon for menu types that have a header and support icons (context) */
    Drawable* mHeaderIcon;
    /** Header custom view for menu types that have a header and support custom views (context) */
    View* mHeaderView;
protected:
    virtual std::string getActionViewStatesKey() {
        return ACTION_VIEW_STATES_KEY;
    }

    void setExclusiveItemChecked(MenuItem& item);
    MenuBuilder& setHeaderTitleInt(const std::string& title);
    MenuBuilder& setHeaderTitleInt(int titleRes);
    MenuBuilder& setHeaderIconInt(Drawable* icon);
    MenuBuilder& setHeaderIconInt(const std::string& iconRes);
    virtual MenuBuilder& setHeaderViewInt(View* view);

    virtual bool isQwertyMode() {
        return mQwertyMode;
    }

    virtual bool dispatchMenuItemSelected(MenuBuilder& menu, MenuItem& item);
    void findItemsWithShortcutForKey(std::vector<MenuItemImpl*>& items, int keyCode, KeyEvent& event);
    MenuItemImpl* findItemWithShortcutForKey(int keyCode, KeyEvent& event);

    void onItemVisibleChanged(MenuItemImpl& item);
    void onItemActionRequestChanged(MenuItemImpl& item);

public:
    MenuBuilder(Context* context);
    MenuBuilder& setDefaultShowAsAction(int defaultShowAsAction);

    void addMenuPresenter(MenuPresenter* presenter);
    void addMenuPresenter(MenuPresenter* presenter, Context* menuContext);
    void removeMenuPresenter(MenuPresenter* presenter);

    void savePresenterStates(Bundle outState);
    void restorePresenterStates(Bundle state);

    void saveActionViewStates(Bundle outStates);
    void restoreActionViewStates(Bundle states);

    virtual void setCallback(Callback cb) {
        mCallback = cb;
    }

    MenuItem* add(const std::string& title) {
        return addInternal(0, 0, 0, title);
    }

    MenuItem* add(int group, int id, int categoryOrder, const std::string& title);
    SubMenu* addSubMenu(const std::string& title);
    SubMenu* addSubMenu(int group, int id, int categoryOrder, const std::string& title);

    virtual void setGroupDividerEnabled(bool groupDividerEnabled) {
        mGroupDividerEnabled = groupDividerEnabled;
    }

    virtual bool isGroupDividerEnabled() {
        return mGroupDividerEnabled;
    }

    //int addIntentOptions(int group, int id, int categoryOrder, ComponentName caller,
    //        Intent[] specifics, Intent intent, int flags, std::vector<MenuItem*>& outSpecificItems);

    void removeItem(int id) {
        removeItemAtInt(findItemIndex(id), true);
    }
    void removeGroup(int group);
    void removeItemAt(int index) {
        removeItemAtInt(index, true);
    }

    void clearAll();
    void clear();

    void setGroupCheckable(int group, bool checkable, bool exclusive);
    void setGroupVisible(int group, bool visible);
    void setGroupEnabled(int group, bool enabled);

    bool hasVisibleItems();

    MenuItem* findItem(int id);
    int findItemIndex(int id);
    int findGroupIndex(int group);
    int findGroupIndex(int group, int start);

    int size() {
        return mItems.size();
    }

    /** {@inheritDoc} */
    MenuItem* getItem(int index) {
        return mItems.at(index);
    }

    bool isShortcutKey(int keyCode, KeyEvent& event) {
        return findItemWithShortcutForKey(keyCode, event) != nullptr;
    }

    virtual void setQwertyMode(bool isQwerty);

    virtual void setShortcutsVisible(bool shortcutsVisible);
    virtual bool isShortcutsVisible() {
        return mShortcutsVisible;
    }

    Context* getContext() {
        return mContext;
    }

    void changeMenuMode();

    bool performShortcut(int keyCode, KeyEvent& event, int flags);

    bool performIdentifierAction(int id, int flags);
    bool performItemAction(MenuItem& item, int flags);
    bool performItemAction(MenuItem& item, MenuPresenter& preferredPresenter, int flags);

    void close(bool closeAllMenus);
    void close() {
        close(true /* closeAllMenus */);
    }

    void onItemsChanged(bool structureChanged);
    void stopDispatchingItemsChanged();
    void startDispatchingItemsChanged();
    std::vector<MenuItemImpl*> getVisibleItems();

    void flagActionItems();

    std::vector<MenuItemImpl*> getActionItems();

    std::vector<MenuItemImpl*> getNonActionItems();

    void clearHeader();

    std::string getHeaderTitle() {
        return mHeaderTitle;
    }

    Drawable* getHeaderIcon() {
        return mHeaderIcon;
    }

    View* getHeaderView() {
        return mHeaderView;
    }

    virtual MenuBuilder* getRootMenu() {
        return this;
    }

    void setCurrentMenuInfo(ContextMenuInfo* menuInfo) {
        mCurrentMenuInfo = menuInfo;
    }

    virtual void setOptionalIconsVisible(bool visible){
        mOptionalIconsVisible = visible;
    }

    bool getOptionalIconsVisible() {
        return mOptionalIconsVisible;
    }

    virtual bool expandItemActionView(MenuItemImpl& item);
    virtual bool collapseItemActionView(MenuItemImpl& item);

    MenuItemImpl* getExpandedItem() {
        return mExpandedItem;
    }
};
}/*endof namespace*/
#endif/*__MENU_BUILDER_H__*/
