#ifndef __MENU_BUILDER_H__
#define __MENU_BUILDER_H__
#include <view/menu.h>
namespace cdroid{
class MenuBuilder:public Menu {
private:
    static final String PRESENTER_KEY = "android:menu:presenters";
    static final String ACTION_VIEW_STATES_KEY = "android:menu:actionviewstates";
    static final String EXPANDED_ACTION_VIEW_ID = "android:menu:expandedactionview";

    static final int[]  sCategoryToOrder = new int[] {
        1, /* No category */
        4, /* CONTAINER */
        5, /* SYSTEM */
        3, /* SECONDARY */
        2, /* ALTERNATIVE */
        0, /* SELECTED_ALTERNATIVE */
    };
public:
    /**
     * Called by menu to notify of close and selection changes.
     */
    struct Callback {
        /**
         * Called when a menu item is selected.
         * @param menu The menu that is the parent of the item
         * @param item The menu item that is selected
         * @return whether the menu item selection was handled
         */
        public bool onMenuItemSelected(MenuBuilder menu, MenuItem item);

        /**
         * Called when the mode of the menu changes (for example, from icon to expanded).
         *
         * @param menu the menu that has changed modes
         */
        public void onMenuModeChange(MenuBuilder menu);
    };

    /**
     * Called by menu items to execute their associated action
     */
    public interface ItemInvoker {
        public bool invokeItem(MenuItemImpl item);
    };
private:
    Context* mContext;

    /**
     * Whether the shortcuts should be qwerty-accessible. Use isQwertyMode()
     * instead of accessing this directly.
     */
    bool mQwertyMode;

    /**
     * Whether the shortcuts should be visible on menus. Use isShortcutsVisible()
     * instead of accessing this directly.
     */
    bool mShortcutsVisible;

    /**
     * Callback that will receive the various menu-related events generated by
     * this class. Use getCallback to get a reference to the callback.
     */
    Callback mCallback;

    /** Contains all of the items for this menu */
    std::vector<MenuItemImpl*> mItems;

    /** Contains only the items that are currently visible.  This will be created/refreshed from
     * {@link #getVisibleItems()} */
    std::vector<MenuItemImpl*> mVisibleItems;

    /**
     * Contains only the items that should appear in the Action Bar, if present.
     */
    std::vector<MenuItemImpl*> mActionItems;
    /**
     * Contains items that should NOT appear in the Action Bar, if present.
     */
    std::vector<MenuItemImpl*> mNonActionItems;

    /**
     * Default value for how added items should show in the action list.
     */
    int mDefaultShowAsAction = MenuItem::SHOW_AS_ACTION_NEVER;

    /**
     * Current use case is Context Menus: As Views populate the context menu, each one has
     * extra information that should be passed along.  This is the current menu info that
     * should be set on all items added to this menu.
     */
    ContextMenuInfo* mCurrentMenuInfo;

    /**
     * Contains the state of the View hierarchy for all menu views when the menu
     * was frozen.
     */
    SparseArray<Parcelable> mFrozenViewStates;

    /**
     * Whether or not the items (or any one item's shown state) has changed since it was last
     * fetched from {@link #getVisibleItems()}
     */
    bool mIsVisibleItemsStale;
    bool mIsActionItemsStale;
    bool mPreventDispatchingItemsChanged = false;
    bool mItemsChangedWhileDispatchPrevented = false;
    bool mOptionalIconsVisible = false;
    bool mIsClosing = false;
    bool mGroupDividerEnabled = false;

    ArrayList<MenuItemImpl> mTempShortcutItemList = new ArrayList<MenuItemImpl>();

    CopyOnWriteArrayList<WeakReference<MenuPresenter>> mPresenters =
            new CopyOnWriteArrayList<WeakReference<MenuPresenter>>();

    /**
     * Currently expanded menu item; must be collapsed when we clear.
     */
    MenuItemImpl* mExpandedItem;

protected:
    /** Header title for menu types that have a header (context and submenus) */
    std::string mHeaderTitle;
    /** Header icon for menu types that have a header and support icons (context) */
    Drawable* mHeaderIcon;
    /** Header custom view for menu types that have a header and support custom views (context) */
    View* mHeaderView;
public:
    public MenuBuilder(Context* context);

    public MenuBuilder setDefaultShowAsAction(int defaultShowAsAction);

    /**
     * Add a presenter to this menu. This will only hold a WeakReference;
     * you do not need to explicitly remove a presenter, but you can using
     * {@link #removeMenuPresenter(MenuPresenter)}.
     *
     * @param presenter The presenter to add
     */
    public void addMenuPresenter(MenuPresenter presenter);

    /**
     * Add a presenter to this menu that uses an alternate context for
     * inflating menu items. This will only hold a WeakReference; you do not
     * need to explicitly remove a presenter, but you can using
     * {@link #removeMenuPresenter(MenuPresenter)}.
     *
     * @param presenter The presenter to add
     * @param menuContext The context used to inflate menu items
     */
    public void addMenuPresenter(MenuPresenter presenter, Context menuContext);

    /**
     * Remove a presenter from this menu. That presenter will no longer
     * receive notifications of updates to this menu's data.
     *
     * @param presenter The presenter to remove
     */
    public void removeMenuPresenter(MenuPresenter presenter);

    private void dispatchPresenterUpdate(bool cleared);

    private bool dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter);

    private void dispatchSaveInstanceState(Bundle outState);

    private void dispatchRestoreInstanceState(Bundle state);

    public void savePresenterStates(Bundle outState);
    public void restorePresenterStates(Bundle state);

    public void saveActionViewStates(Bundle outStates);
    public void restoreActionViewStates(Bundle states);

    protected String getActionViewStatesKey() {
        return ACTION_VIEW_STATES_KEY;
    }

    public void setCallback(Callback cb) {
        mCallback = cb;
    }

    /**
     * Adds an item to the menu.  The other add methods funnel to this.
     */
    private MenuItem addInternal(int group, int id, int categoryOrder, const std::string& title);

    // Layoutlib overrides this method to return its custom implementation of MenuItemImpl
    private MenuItemImpl createNewMenuItem(int group, int id, int categoryOrder, int ordering,
            CharSequence title, int defaultShowAsAction);

    public MenuItem add(CharSequence title) {
        return addInternal(0, 0, 0, title);
    }

    public MenuItem add(int titleRes);
    public MenuItem add(int group, int id, int categoryOrder, const std::string& title);
    public MenuItem add(int group, int id, int categoryOrder, int title);
    public SubMenu addSubMenu(CharSequence title);
    public SubMenu addSubMenu(int titleRes);

    public SubMenu addSubMenu(int group, int id, int categoryOrder, const std::string& title);
    public SubMenu addSubMenu(int group, int id, int categoryOrder, int title);

    public void setGroupDividerEnabled(bool groupDividerEnabled) {
        mGroupDividerEnabled = groupDividerEnabled;
    }

    public bool isGroupDividerEnabled() {
        return mGroupDividerEnabled;
    }

    public int addIntentOptions(int group, int id, int categoryOrder, ComponentName caller,
            Intent[] specifics, Intent intent, int flags, MenuItem[] outSpecificItems);

    public void removeItem(int id) {
        removeItemAtInt(findItemIndex(id), true);
    }

    public void removeGroup(int group);

    /**
     * Remove the item at the given index and optionally forces menu views to
     * update.
     *
     * @param index The index of the item to be removed. If this index is
     *            invalid an exception is thrown.
     * @param updateChildrenOnMenuViews Whether to force update on menu views.
     *            Please make sure you eventually call this after your batch of
     *            removals.
     */
    private void removeItemAtInt(int index, bool updateChildrenOnMenuViews);

    public void removeItemAt(int index) {
        removeItemAtInt(index, true);
    }

    public void clearAll();
    public void clear();

    void setExclusiveItemChecked(MenuItem item);

    public void setGroupCheckable(int group, bool checkable, bool exclusive);

    public void setGroupVisible(int group, bool visible);

    public void setGroupEnabled(int group, bool enabled);

    public bool hasVisibleItems();

    public MenuItem findItem(int id);
    public int findItemIndex(int id);

    public int findGroupIndex(int group);
    
    public int findGroupIndex(int group, int start);

    public int size() {
        return mItems.size();
    }

    /** {@inheritDoc} */
    public MenuItem getItem(int index) {
        return mItems.get(index);
    }

    public bool isShortcutKey(int keyCode, KeyEvent& event) {
        return findItemWithShortcutForKey(keyCode, event) != null;
    }

    public void setQwertyMode(bool isQwerty);

    /**
     * Returns the ordering across all items. This will grab the category from
     * the upper bits, find out how to order the category with respect to other
     * categories, and combine it with the lower bits.
     *
     * @param categoryOrder The category order for a particular item (if it has
     *            not been or/add with a category, the default category is
     *            assumed).
     * @return An ordering integer that can be used to order this item across
     *         all the items (even from other categories).
     */
    private static int getOrdering(int categoryOrder);

    /**
     * @return whether the menu shortcuts are in qwerty mode or not
     */
    bool isQwertyMode() {
        return mQwertyMode;
    }

    /**
     * Sets whether the shortcuts should be visible on menus.  Devices without hardware
     * key input will never make shortcuts visible even if this method is passed 'true'.
     *
     * @param shortcutsVisible Whether shortcuts should be visible (if true and a
     *            menu item does not have a shortcut defined, that item will
     *            still NOT show a shortcut)
     */
    public void setShortcutsVisible(bool shortcutsVisible);

    private void setShortcutsVisibleInner(bool shortcutsVisible);

    /**
     * @return Whether shortcuts should be visible on menus.
     */
    public bool isShortcutsVisible() {
        return mShortcutsVisible;
    }

    public Context* getContext() {
        return mContext;
    }

    bool dispatchMenuItemSelected(MenuBuilder menu, MenuItem item);
    /**
     * Dispatch a mode change event to this menu's callback.
     */
    public void changeMenuMode();

    private static int findInsertIndex(ArrayList<MenuItemImpl> items, int ordering);

    public bool performShortcut(int keyCode, KeyEvent& event, int flags);

    /*
     * This function will return all the menu and sub-menu items that can
     * be directly (the shortcut directly corresponds) and indirectly
     * (the ALT-enabled char corresponds to the shortcut) associated
     * with the keyCode.
     */
    void findItemsWithShortcutForKey(List<MenuItemImpl> items, int keyCode, KeyEvent& event);
    /*
     * We want to return the menu item associated with the key, but if there is no
     * ambiguity (i.e. there is only one menu item corresponding to the key) we want
     * to return it even if it's not an exact match; this allow the user to
     * _not_ use the ALT key for example, making the use of shortcuts slightly more
     * user-friendly. An example is on the G1, '!' and '1' are on the same key, and
     * in Gmail, Menu+1 will trigger Menu+! (the actual shortcut).
     *
     * On the other hand, if two (or more) shortcuts corresponds to the same key,
     * we have to only return the exact match.
     */
    MenuItemImpl findItemWithShortcutForKey(int keyCode, KeyEvent& event);

    public bool performIdentifierAction(int id, int flags);
    public bool performItemAction(MenuItem item, int flags);
    public bool performItemAction(MenuItem item, MenuPresenter preferredPresenter, int flags);

    /**
     * Closes the menu.
     *
     * @param closeAllMenus {@code true} if all displayed menus and submenus
     *                      should be completely closed (as when a menu item is
     *                      selected) or {@code false} if only this menu should
     *                      be closed
     */
    public final void close(bool closeAllMenus);

    /** {@inheritDoc} */
    public void close() {
        close(true /* closeAllMenus */);
    }

    /**
     * Called when an item is added or removed.
     *
     * @param structureChanged true if the menu structure changed,
     *                         false if only item properties changed.
     *                         (Visibility is a structural property since it affects layout.)
     */
    public void onItemsChanged(bool structureChanged);

    /**
     * Stop dispatching item changed events to presenters until
     * {@link #startDispatchingItemsChanged()} is called. Useful when
     * many menu operations are going to be performed as a batch.
     */
    public void stopDispatchingItemsChanged();

    public void startDispatchingItemsChanged();

    /**
     * Called by {@link MenuItemImpl} when its visible flag is changed.
     * @param item The item that has gone through a visibility change.
     */
    void onItemVisibleChanged(MenuItemImpl item);

    /**
     * Called by {@link MenuItemImpl} when its action request status is changed.
     * @param item The item that has gone through a change in action request status.
     */
    void onItemActionRequestChanged(MenuItemImpl item);

    public std::vector<MenuItemImpl*> getVisibleItems();

    /**
     * This method determines which menu items get to be 'action items' that will appear
     * in an action bar and which items should be 'overflow items' in a secondary menu.
     * The rules are as follows:
     *
     * <p>Items are considered for inclusion in the order specified within the menu.
     * There is a limit of mMaxActionItems as a total count, optionally including the overflow
     * menu button itself. This is a soft limit; if an item shares a group ID with an item
     * previously included as an action item, the new item will stay with its group and become
     * an action item itself even if it breaks the max item count limit. This is done to
     * limit the conceptual complexity of the items presented within an action bar. Only a few
     * unrelated concepts should be presented to the user in this space, and groups are treated
     * as a single concept.
     *
     * <p>There is also a hard limit of consumed measurable space: mActionWidthLimit. This
     * limit may be broken by a single item that exceeds the remaining space, but no further
     * items may be added. If an item that is part of a group cannot fit within the remaining
     * measured width, the entire group will be demoted to overflow. This is done to ensure room
     * for navigation and other affordances in the action bar as well as reduce general UI clutter.
     *
     * <p>The space freed by demoting a full group cannot be consumed by future menu items.
     * Once items begin to overflow, all future items become overflow items as well. This is
     * to avoid inadvertent reordering that may break the app's intended design.
     */
    public void flagActionItems();

    public std::vector<MenuItemImpl*> getActionItems();

    public std::vector<MenuItemImpl*> getNonActionItems();

    public void clearHeader();

    private void setHeaderInternal(final int titleRes, final CharSequence title, final int iconRes,
            Drawable* icon, final View view);

    /**
     * Sets the header's title. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param title The new title.
     * @return This MenuBuilder so additional setters can be called.
     */
    protected MenuBuilder setHeaderTitleInt(const std::string& title);

    /**
     * Sets the header's title. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param titleRes The new title (as a resource ID).
     * @return This MenuBuilder so additional setters can be called.
     */
    protected MenuBuilder setHeaderTitleInt(int titleRes);

    /**
     * Sets the header's icon. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param icon The new icon.
     * @return This MenuBuilder so additional setters can be called.
     */
    protected MenuBuilder setHeaderIconInt(Drawable* icon);

    /**
     * Sets the header's icon. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param iconRes The new icon (as a resource ID).
     * @return This MenuBuilder so additional setters can be called.
     */
    protected MenuBuilder setHeaderIconInt(int iconRes);

    /**
     * Sets the header's view. This replaces the title and icon. Called by the
     * builder-style methods of subclasses.
     *
     * @param view The new view.
     * @return This MenuBuilder so additional setters can be called.
     */
    protected MenuBuilder setHeaderViewInt(View view);

    public std::string getHeaderTitle() {
        return mHeaderTitle;
    }

    public Drawable* getHeaderIcon() {
        return mHeaderIcon;
    }

    public View getHeaderView() {
        return mHeaderView;
    }

    /**
     * Gets the root menu (if this is a submenu, find its root menu).
     * @return The root menu.
     */
    public MenuBuilder getRootMenu() {
        return this;
    }

    /**
     * Sets the current menu info that is set on all items added to this menu
     * (until this is called again with different menu info, in which case that
     * one will be added to all subsequent item additions).
     *
     * @param menuInfo The extra menu information to add.
     */
    public void setCurrentMenuInfo(ContextMenuInfo* menuInfo) {
        mCurrentMenuInfo = menuInfo;
    }

    /**
     * Sets the optional icon visible.
     * @param visible true for visible, false for hidden.
     */
    @Override
    public void setOptionalIconsVisible(bool visible) {
        mOptionalIconsVisible = visible;
    }

    bool getOptionalIconsVisible() {
        return mOptionalIconsVisible;
    }

    public bool expandItemActionView(MenuItemImpl item);

    public bool collapseItemActionView(MenuItemImpl item);

    public MenuItemImpl getExpandedItem() {
        return mExpandedItem;
    }
};
}/*endof namespace*/
#endif/*__MENU_BUILDER_H__*/
